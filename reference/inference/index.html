



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.3">
    
    
      
        <title>Inference - delfi</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.30686662.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css">
    
      <link rel="stylesheet" href="../../static/global.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#inference" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="delfi" class="md-header-nav__button md-logo">
          
            <img src="../../static/logo.svg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              delfi
            </span>
            <span class="md-header-nav__topic">
              
                Inference
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://github.com/mackelab/delfi/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    mackelab/delfi
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="delfi" class="md-nav__button md-logo">
      
        <img src="../../static/logo.svg" width="48" height="48">
      
    </a>
    delfi
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://github.com/mackelab/delfi/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    mackelab/delfi
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../install/" title="Installation" class="md-nav__link">
      Installation
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../tutorials/quickstart/" title="Tutorial" class="md-nav__link">
      Tutorial
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Reference
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Reference
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../distributions/" title="Distributions" class="md-nav__link">
      Distributions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../generator/" title="Generator" class="md-nav__link">
      Generator
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Inference
      </label>
    
    <a href="./" title="Inference" class="md-nav__link md-nav__link--active">
      Inference
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#Basic" class="md-nav__link">
    Basic
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEA" class="md-nav__link">
    SNPEA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEB" class="md-nav__link">
    SNPEB
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEC" class="md-nav__link">
    SNPEC
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../neuralnet/" title="Neural Networks" class="md-nav__link">
      Neural Networks
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../utils/" title="Utilities" class="md-nav__link">
      Utilities
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../credits/" title="Credits" class="md-nav__link">
      Credits
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#Basic" class="md-nav__link">
    Basic
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEA" class="md-nav__link">
    SNPEA
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEB" class="md-nav__link">
    SNPEB
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#SNPEC" class="md-nav__link">
    SNPEC
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/mackelab/delfi/edit/master/docs/reference/inference.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="inference">Inference<a class="headerlink" href="#inference" title="Permanent link">&para;</a></h1>
<h2 id="Basic"><strong>Basic</strong><code class="codehilite"><span class="k">class</span></code><a class="headerlink" href="#Basic" title="Permanent link">&para;</a></h2>
<h3 data-toc-label="__init__" id="__init__"><em>Basic</em>.<strong>__init__</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Basic inference algorithm

Uses samples from the prior for density estimation likelihood-free
inference.

Parameters
----------
generator : generator instance
    Generator instance
obs : array or None
    Observation in the format the generator returns (1 x n_summary)
prior_norm : bool
    If set to True, will z-transform params based on mean/std of prior
pilot_samples : None or int
    If an integer is provided, a pilot run with the given number of
    samples is run. The mean and std of the summary statistics of the
    pilot samples will be subsequently used to z-transform summary
    statistics.
reg_lambda : float
    Precision parameter for weight regularizer if svi is True
seed : int or None
    If provided, random number generator will be seeded
kwargs : additional keyword arguments
    Additional arguments for the NeuralNet instance, including:
        n_components : int
            Number of components of the mixture density
        n_hiddens : list of ints
            Number of hidden units per layer of the neural network
        svi : bool
            Whether to use SVI version of the network or not

Attributes
----------
observables : dict
    Dictionary containing theano variables that can be monitored while
    training the neural network.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="n">prior_norm</span><span class="p">,</span>
                     <span class="n">pilot_samples</span><span class="o">=</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="centre_on_obs" id="centre_on_obs"><em>Basic</em>.<strong>centre_on_obs</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Centres first-layer input onto observed summary statistics

Ensures x&#39; = x - xo, i.e. first-layer input x&#39; = 0 for x = xo.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">centre_on_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>


    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="compile_observables" id="compile_observables"><em>Basic</em>.<strong>compile_observables</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Creates observables dict
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile_observables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">aps</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="conditional_norm" id="conditional_norm"><em>Basic</em>.<strong>conditional_norm</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Normalizes current network output at observed summary statistics

Parameters
----------
fcv : float
    Fraction of total that comes from uncertainty over components, i.e.
    Var[th] = E[Var[th|z]] + Var[E[th|z]]
            =  (1-fcv)     +     fcv       = 1
tmu: array
    Target mean.
tSig: array
    Target covariance.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">conditional_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


    <span class="c1"># avoid CDELFI.predict() attempt to analytically correct for proposal</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">obz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_mog</span><span class="p">(</span><span class="n">obz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                     <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mog</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># assumes uniform alpha</span>

    <span class="n">n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">]</span>
    <span class="n">triu_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diag_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># compute MoG mean mu, Sig = E[Var[th|z]] and C = Var[E[th|z]]</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">Sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">Sig</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">S</span>
        <span class="n">mu</span>  <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">mu</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> \
            <span class="k">else</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dmu</span><span class="p">,</span> <span class="n">dmu</span><span class="p">)</span>

    <span class="c1"># if not provided, target zero-mean unit variance (as for prior_norm=True)</span>
    <span class="n">tmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmu</span>
    <span class="n">tSig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">tSig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tSig</span>

    <span class="c1"># compute normalizers (we only z-score, don&#39;t whiten!)</span>
    <span class="n">Z1inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">fcv</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Z2inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">fcv</span>    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># first we need the center of means</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;means&#39;</span>
    <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h</span>
        <span class="n">mu_</span> <span class="o">+=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">mu_</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># center and normalize means</span>
    <span class="c1"># mu =  Z2inv * (Wh + b - mu_) + tmu</span>
    <span class="c1">#    = Wh + (Z2inv * (b - mu_ + Wh) - Wh + tum)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">Z2inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">Wh</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">-</span> <span class="n">mu_</span><span class="p">)</span> <span class="o">-</span> <span class="n">Wh</span> <span class="o">+</span> <span class="n">tmu</span><span class="p">)</span>

    <span class="c1"># normalize covariances</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;precisions&#39;</span>
    <span class="c1"># Sig^-0.5 = diag_mask * (exp(Wh+b)/exp(log(Z1)) + triu_mask * (Wh+b)*Z1</span>
    <span class="c1">#          = diag_mask *  exp(Wh+ (b-log(Z1))    + triu_mask * (Wh+((b+Wh)*Z1-Wh))</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">diag_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z1inv</span><span class="p">)))</span> <span class="o">+</span> <span class="n">triu_mask</span> <span class="o">*</span> <span class="p">((</span><span class="n">b_</span><span class="o">+</span><span class="n">Wh</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">Z1inv</span><span class="p">))</span><span class="o">-</span> <span class="n">Wh</span> <span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen" id="gen"><em>Basic</em>.<strong>gen</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate from generator and z-transform

Parameters
----------
n_samples : int
    Number of samples to generate
n_reps : int
    Number of repeats per parameter
verbose : None or bool or str
    If None is passed, will default to self.verbose
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">n_reps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;n_reps &gt; 1 is not yet supported&#39;</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">verbose</span>

    <span class="n">n_pilot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">n_pilot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">:</span>  <span class="c1"># reuse pilot samples</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:],</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:])</span>
        <span class="n">n_samples</span> <span class="o">-=</span> <span class="n">n_pilot</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">params_rem</span><span class="p">,</span> <span class="n">stats_rem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                                       <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">params</span><span class="p">,</span> <span class="n">params_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">stats</span><span class="p">,</span> <span class="n">stats_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                           <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># z-transform params and stats</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>

    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">stats</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen_newseed" id="gen_newseed"><em>Basic</em>.<strong>gen_newseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generates a new random seed
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen_newseed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="loss" id="loss"><em>Basic</em>.<strong>loss</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Loss function for training

Parameters
----------
N : int
    Number of training samples
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">tt</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&lt;=</span> <span class="n">round_cl</span><span class="p">:</span>
            <span class="c1"># weights close to zero-centered prior in the first round</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># weights close to those of previous round</span>
            <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span> <span class="o">*</span> <span class="n">kl</span>

    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="monitor_dict_from_names" id="monitor_dict_from_names"><em>Basic</em>.<strong>monitor_dict_from_names</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate monitor dict from list of variable names
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">monitor_dict_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">monitor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">monitor</span> <span class="o">=</span> <span class="p">[</span><span class="n">monitor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monitor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>
                <span class="n">observe</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">observe</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="norm_init" id="norm_init"><em>Basic</em>.<strong>norm_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">norm_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_norm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;standardizing network initialization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_fcv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="pilot_run" id="pilot_run"><em>Basic</em>.<strong>pilot_run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Pilot run in order to find parameters for z-scoring stats
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pilot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">pilot_samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pilot_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">):</span>  <span class="c1"># determine via pilot run</span>
        <span class="k">assert</span> <span class="n">pilot_samples</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># reseed generator for consistent inits</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(pilot run) &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># samples were provided as an input</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">pilot_samples</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">,</span> <span class="n">min_std</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="n">ok_sims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:],</span> <span class="n">stats</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="predict" id="predict"><em>Basic</em>.<strong>predict</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Predict posterior given x

Parameters
----------
x : array
    Stats for which to compute the posterior
deterministic : bool
    if True, mean weights are used for Bayesian network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>
    <span class="c1"># z-transform inputs</span>
    <span class="n">x_zt</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>

    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_density</span><span class="p">(</span><span class="n">x_zt</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">)</span>

    <span class="c1"># z-transform outputs</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;maf&#39;</span><span class="p">:</span>
        <span class="n">posterior</span><span class="o">.</span><span class="n">set_scale_and_offset</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">,</span>
                                       <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_std</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posterior</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reinit_network" id="reinit_network"><em>Basic</em>.<strong>reinit_network</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Reinitializes the network instance (re-setting the weights!)
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reinit_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">NeuralNet</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">svi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">svi</span> <span class="k">if</span> <span class="s1">&#39;svi&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">update</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="n">so</span> <span class="n">that</span> <span class="n">reinitializing</span> <span class="n">the</span> <span class="n">network</span> <span class="n">gives</span> <span class="n">a</span>
    <span class="n">different</span> <span class="n">result</span> <span class="n">each</span> <span class="n">time</span> <span class="n">unless</span> <span class="n">we</span> <span class="n">reseed</span> <span class="n">the</span> <span class="n">inference</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">norm_init</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="remove_hidden_biases" id="remove_hidden_biases"><em>Basic</em>.<strong>remove_hidden_biases</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets all bias weights in hidden layers to zero.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_hidden_biases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">idx_hiddens</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">idx_hiddens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">):</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reseed" id="reseed"><em>Basic</em>.<strong>reseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>reseed inference method&#39;s RNG, then generator, then network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reseed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>   <span class="c1"># for consistent NN init</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># also reseeds prior + model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># for reproducible samples</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reset" id="reset"><em>Basic</em>.<strong>reset</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets inference method to a naive state, before it has seen any
real or simulated data. The following happens, in order:
1) The generator&#39;s proposal is set to None, and self.round is set to 0
2) The inference method is reseeded if a seed is provided
3) The network is reinitialized
4) Any additional resetting of state specific to each inference method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reinit_network</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run" id="run"><em>Basic</em>.<strong>run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Run algorithm

Parameters
----------
n_train : int or list of ints
    Number of data points drawn per round. If a list is passed, the
    nth list element specifies the number of training examples in the
    nth round. If there are fewer list elements than rounds, the last
    list element is used.
n_rounds : int
    Number of rounds
epochs : int
    Number of epochs used for neural network training
minibatch : int
    Size of the minibatches used for neural network training
monitor : list of str
    Names of variables to record during training along with the value
    of the loss function. The observables attribute contains all
    possible variables that can be monitored
round_cl : int
    Round after which to start continual learning
stop_on_nan : bool
    If True, will halt if NaNs in the loss are encountered
kwargs : additional keyword arguments
    Additional arguments for the Trainer instance

Returns
-------
logs : list of dicts
    Dictionaries contain information logged while training the networks
trn_datasets : list of (params, stats)
    training datasets, z-transformed
posteriors : list of distributions
    posterior after each round
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trn_datasets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">posteriors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># number of training examples for this round</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span>

        <span class="c1"># draw training data (z-transformed params and stats)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(round </span><span class="si">{}</span><span class="s1">) &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">trn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">trn_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">trn_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stats</span><span class="p">]</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">),</span>
                    <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                    <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="n">stop_on_nan</span><span class="p">))</span>
        <span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Posterior inference failed&#39;</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">logs</span><span class="p">,</span> <span class="n">trn_datasets</span><span class="p">,</span> <span class="n">posteriors</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_repeated" id="run_repeated"><em>Basic</em>.<strong>run_repeated</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Repeatedly run the method and collect results. Optionally, carry out
several runs with the same initial generator RNG state but different
neural network initializations.

parameters
----------
n_repeats : int
    Number of times to run the algorithm
n_NN_inits : int
    Number of times to
callback: function
    callback function that will be called after each run. It should
    take 4 inputs: callback(log, train_data, posterior, self)
kwargs : additional keyword arguments
    Additional arguments that will be passed to the run() method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_repeated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">generator_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_NN_inits_per_repeat</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">generator_seed</span><span class="p">)</span>

            <span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
            <span class="n">repeat_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="standardize_init" id="standardize_init"><em>Basic</em>.<strong>standardize_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Standardizes the network initialization on obs

Ensures output distributions for xo have mean zero and unit variance.
Alters hidden layers to propagates x=xo as zero to the last layer, and
alters the MoG layers to produce the desired output distribution.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">standardize_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>

    <span class="c1"># ensure x&#39; = x - xo</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">centre_on_obs</span><span class="p">()</span>

    <span class="c1"># ensure x&#39; = 0 stays zero up to MoG layer (setting biases to zero)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">remove_hidden_biases</span><span class="p">()</span>

    <span class="c1"># ensure MoG returns standardized output on x&#39; = 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">conditional_norm</span><span class="p">(</span><span class="n">fcv</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h2 id="SNPEA"><strong>SNPEA</strong><code class="codehilite"><span class="k">class</span></code><a class="headerlink" href="#SNPEA" title="Permanent link">&para;</a></h2>
<h3 data-toc-label="__init__" id="__init__"><em>SNPEA</em>.<strong>__init__</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>SNPE-A

Implementation of Papamakarios &amp; Murray (NeurIPS 2016)

Parameters
----------
generator : generator instance
    Generator instance
obs : array
    Observation in the format the generator returns (1 x n_summary)
prior_norm : bool
    If set to True, will z-transform params based on mean/std of prior
pilot_samples : None or int
    If an integer is provided, a pilot run with the given number of
    samples is run. The mean and std of the summary statistics of the
    pilot samples will be subsequently used to z-transform summary
    statistics.
n_components : int
    Number of components in final round (PM&#39;s algorithm 2)
reg_lambda : float
    Precision parameter for weight regularizer if svi is True
seed : int or None
    If provided, random number generator will be seeded
verbose : bool
    Controls whether or not progressbars are shown
kwargs : additional keyword arguments
    Additional arguments for the NeuralNet instance, including:
        n_hiddens : list of ints
            Number of hidden units per layer of the neural network
        svi : bool
            Whether to use SVI version of the network or not

Attributes
----------
observables : dict
    Dictionary containing theano variables that can be monitored while
    training the neural network.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="n">n_components</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;CDELFI requires observed data&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observed data contains NaNs&quot;</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="n">prior_norm</span><span class="p">,</span>
                     <span class="n">pilot_samples</span><span class="o">=</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># we&#39;ll use only 1 component until the last round</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="centre_on_obs" id="centre_on_obs"><em>SNPEA</em>.<strong>centre_on_obs</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Centres first-layer input onto observed summary statistics

Ensures x&#39; = x - xo, i.e. first-layer input x&#39; = 0 for x = xo.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">centre_on_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>


    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="compile_observables" id="compile_observables"><em>SNPEA</em>.<strong>compile_observables</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Creates observables dict
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile_observables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">aps</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="conditional_norm" id="conditional_norm"><em>SNPEA</em>.<strong>conditional_norm</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Normalizes current network output at observed summary statistics

Parameters
----------
fcv : float
    Fraction of total that comes from uncertainty over components, i.e.
    Var[th] = E[Var[th|z]] + Var[E[th|z]]
            =  (1-fcv)     +     fcv       = 1
tmu: array
    Target mean.
tSig: array
    Target covariance.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">conditional_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


    <span class="c1"># avoid CDELFI.predict() attempt to analytically correct for proposal</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">obz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_mog</span><span class="p">(</span><span class="n">obz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                     <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mog</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># assumes uniform alpha</span>

    <span class="n">n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">]</span>
    <span class="n">triu_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diag_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># compute MoG mean mu, Sig = E[Var[th|z]] and C = Var[E[th|z]]</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">Sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">Sig</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">S</span>
        <span class="n">mu</span>  <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">mu</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> \
            <span class="k">else</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dmu</span><span class="p">,</span> <span class="n">dmu</span><span class="p">)</span>

    <span class="c1"># if not provided, target zero-mean unit variance (as for prior_norm=True)</span>
    <span class="n">tmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmu</span>
    <span class="n">tSig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">tSig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tSig</span>

    <span class="c1"># compute normalizers (we only z-score, don&#39;t whiten!)</span>
    <span class="n">Z1inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">fcv</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Z2inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">fcv</span>    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># first we need the center of means</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;means&#39;</span>
    <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h</span>
        <span class="n">mu_</span> <span class="o">+=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">mu_</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># center and normalize means</span>
    <span class="c1"># mu =  Z2inv * (Wh + b - mu_) + tmu</span>
    <span class="c1">#    = Wh + (Z2inv * (b - mu_ + Wh) - Wh + tum)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">Z2inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">Wh</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">-</span> <span class="n">mu_</span><span class="p">)</span> <span class="o">-</span> <span class="n">Wh</span> <span class="o">+</span> <span class="n">tmu</span><span class="p">)</span>

    <span class="c1"># normalize covariances</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;precisions&#39;</span>
    <span class="c1"># Sig^-0.5 = diag_mask * (exp(Wh+b)/exp(log(Z1)) + triu_mask * (Wh+b)*Z1</span>
    <span class="c1">#          = diag_mask *  exp(Wh+ (b-log(Z1))    + triu_mask * (Wh+((b+Wh)*Z1-Wh))</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">diag_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z1inv</span><span class="p">)))</span> <span class="o">+</span> <span class="n">triu_mask</span> <span class="o">*</span> <span class="p">((</span><span class="n">b_</span><span class="o">+</span><span class="n">Wh</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">Z1inv</span><span class="p">))</span><span class="o">-</span> <span class="n">Wh</span> <span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen" id="gen"><em>SNPEA</em>.<strong>gen</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate from generator and z-transform

Parameters
----------
n_samples : int
    Number of samples to generate
n_reps : int
    Number of repeats per parameter
verbose : None or bool or str
    If None is passed, will default to self.verbose
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">n_reps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;n_reps &gt; 1 is not yet supported&#39;</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">verbose</span>

    <span class="n">n_pilot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">n_pilot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">:</span>  <span class="c1"># reuse pilot samples</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:],</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:])</span>
        <span class="n">n_samples</span> <span class="o">-=</span> <span class="n">n_pilot</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">params_rem</span><span class="p">,</span> <span class="n">stats_rem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                                       <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">params</span><span class="p">,</span> <span class="n">params_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">stats</span><span class="p">,</span> <span class="n">stats_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                           <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># z-transform params and stats</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>

    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">stats</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen_newseed" id="gen_newseed"><em>SNPEA</em>.<strong>gen_newseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generates a new random seed
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen_newseed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="loss" id="loss"><em>SNPEA</em>.<strong>loss</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Loss function for training

Parameters
----------
N : int
    Number of training samples
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">tt</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">:</span>
        <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">kl</span>

        <span class="c1"># adding nodes to dict s.t. they can be monitored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.kl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">imvs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="monitor_dict_from_names" id="monitor_dict_from_names"><em>SNPEA</em>.<strong>monitor_dict_from_names</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate monitor dict from list of variable names
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">monitor_dict_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">monitor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">monitor</span> <span class="o">=</span> <span class="p">[</span><span class="n">monitor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monitor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>
                <span class="n">observe</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">observe</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="norm_init" id="norm_init"><em>SNPEA</em>.<strong>norm_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">norm_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_norm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;standardizing network initialization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_fcv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="pilot_run" id="pilot_run"><em>SNPEA</em>.<strong>pilot_run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Pilot run in order to find parameters for z-scoring stats
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pilot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">pilot_samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pilot_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">):</span>  <span class="c1"># determine via pilot run</span>
        <span class="k">assert</span> <span class="n">pilot_samples</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># reseed generator for consistent inits</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(pilot run) &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># samples were provided as an input</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">pilot_samples</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">,</span> <span class="n">min_std</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="n">ok_sims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:],</span> <span class="n">stats</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="predict" id="predict"><em>SNPEA</em>.<strong>predict</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Predict posterior given x

Parameters
----------
x : array
    Stats for which to compute the posterior
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no correction necessary</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># via super</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># mog is posterior given proposal prior</span>
        <span class="n">mog</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># via super</span>

        <span class="n">mog</span><span class="o">.</span><span class="n">prune_negligible_components</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

        <span class="c1"># compute posterior given prior by analytical division step</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Uniform</span><span class="p">):</span>
            <span class="n">posterior</span> <span class="o">=</span> <span class="n">mog</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">):</span>
            <span class="n">posterior</span> <span class="o">=</span> <span class="p">(</span><span class="n">mog</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span> <span class="o">/</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="n">posterior</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reinit_network" id="reinit_network"><em>SNPEA</em>.<strong>reinit_network</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Reinitializes the network instance (re-setting the weights!)
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reinit_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">NeuralNet</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">svi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">svi</span> <span class="k">if</span> <span class="s1">&#39;svi&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">update</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="n">so</span> <span class="n">that</span> <span class="n">reinitializing</span> <span class="n">the</span> <span class="n">network</span> <span class="n">gives</span> <span class="n">a</span>
    <span class="n">different</span> <span class="n">result</span> <span class="n">each</span> <span class="n">time</span> <span class="n">unless</span> <span class="n">we</span> <span class="n">reseed</span> <span class="n">the</span> <span class="n">inference</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">norm_init</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="remove_hidden_biases" id="remove_hidden_biases"><em>SNPEA</em>.<strong>remove_hidden_biases</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets all bias weights in hidden layers to zero.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_hidden_biases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">idx_hiddens</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">idx_hiddens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">):</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reseed" id="reseed"><em>SNPEA</em>.<strong>reseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>reseed inference method&#39;s RNG, then generator, then network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reseed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>   <span class="c1"># for consistent NN init</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># also reseeds prior + model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># for reproducible samples</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reset" id="reset"><em>SNPEA</em>.<strong>reset</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets inference method to a naive state, before it has seen any
real or simulated data. The following happens, in order:
1) The generator&#39;s proposal is set to None, and self.round is set to 0
2) The inference method is reseeded if a seed is provided
3) The network is reinitialized
4) Any additional resetting of state specific to each inference method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reinit_network</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run" id="run"><em>SNPEA</em>.<strong>run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Run algorithm

Parameters
----------
n_train : int or list of ints
    Number of data points drawn per round. If a list is passed, the
    nth list element specifies the number of training examples in the
    nth round. If there are fewer list elements than rounds, the last
    list element is used.
n_rounds : int
    Number of rounds
epochs: int
    Number of epochs used for neural network training
minibatch: int
    Size of the minibatches used for neural network training
monitor : list of str
    Names of variables to record during training along with the value
    of the loss function. The observables attribute contains all
    possible variables that can be monitored
kwargs : additional keyword arguments
    Additional arguments for the Trainer instance

Returns
-------
logs : list of dicts
    Dictionaries contain information logged while training the networks
trn_datasets : list of (params, stats)
    training datasets, z-transformed
posteriors : list of posteriors
    posterior after each round
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span>
69
<span class="special">70</span>
71
<span class="special">72</span>
73
<span class="special">74</span>
75
<span class="special">76</span>
77
<span class="special">78</span>
79
<span class="special">80</span>
81
<span class="special">82</span>
83
<span class="special">84</span>
85
<span class="special">86</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trn_datasets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">posteriors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>  <span class="c1"># start at 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># if round &gt; 1, set new proposal distribution before sampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># posterior becomes new proposal prior</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">project_to_gaussian</span><span class="p">()</span>
        <span class="c1"># number of training examples for this round</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span>

        <span class="c1"># draw training data (z-transformed params and stats)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(round </span><span class="si">{}</span><span class="s1">) &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">trn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># algorithm 2 of Papamakarios and Murray</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">n_rounds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># get parameters of current network</span>
            <span class="n">old_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># create new network</span>
            <span class="n">network_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">spec_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">network_spec</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">NeuralNet</span><span class="p">(</span><span class="o">**</span><span class="n">network_spec</span><span class="p">)</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params_dict</span>

            <span class="n">In</span> <span class="n">order</span> <span class="n">to</span> <span class="n">go</span> <span class="kn">from</span> <span class="mi">1</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">previous</span> <span class="n">rounds</span> <span class="n">to</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">current</span> <span class="nb">round</span> <span class="n">we</span> <span class="n">will</span> <span class="n">duplicate</span>
            <span class="n">component</span> <span class="mi">1</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="n">times</span><span class="p">,</span> <span class="k">with</span> <span class="n">small</span> <span class="n">random</span>
            <span class="n">perturbations</span> <span class="n">to</span> <span class="n">the</span> <span class="n">parameters</span> <span class="n">affecting</span> <span class="n">component</span> <span class="n">means</span>
            <span class="ow">and</span> <span class="n">precisions</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">SVI</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">s</span> <span class="n">of</span> <span class="n">those</span> <span class="n">parameters</span><span class="o">.</span> <span class="n">Set</span> <span class="n">the</span>
            <span class="n">mixture</span> <span class="n">coefficients</span> <span class="n">to</span> <span class="nb">all</span> <span class="n">be</span> <span class="n">equal</span>
            <span class="n">mp_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_params</span> <span class="k">if</span> <span class="s1">&#39;means&#39;</span> <span class="ow">in</span> <span class="n">s</span> <span class="ow">or</span> \
                <span class="s1">&#39;precisions&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># list of dict keys</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">mp_param_names</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">each</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">get</span> <span class="n">the</span> <span class="n">corresponding</span> <span class="n">old</span> <span class="n">parameter</span>
                <span class="n">name</span><span class="o">/</span><span class="n">value</span> <span class="k">for</span> <span class="n">what</span> <span class="n">was</span> <span class="n">previously</span> <span class="n">the</span> <span class="n">only</span> <span class="n">mixture</span>
                <span class="n">component</span>
                <span class="n">param_label</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;\d&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span> <span class="c1"># removing layer counts</span>
                <span class="n">source_param_name</span> <span class="o">=</span> <span class="n">param_label</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span>
                <span class="n">source_param_val</span> <span class="o">=</span> <span class="n">old_params</span><span class="p">[</span><span class="n">source_param_name</span><span class="p">]</span>
                <span class="c1"># copy it to the new component, add noise to break symmetry</span>
                <span class="n">old_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_param_val</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> \
                    <span class="mf">1.0e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">source_param_val</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># initialize with equal mixture coefficients for all data</span>
            <span class="n">old_params</span><span class="p">[</span><span class="s1">&#39;weights.mW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span> <span class="o">*</span> <span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;weights.mW&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">old_params</span><span class="p">[</span><span class="s1">&#39;weights.mb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span> <span class="o">*</span> <span class="n">new_params</span><span class="p">[</span><span class="s1">&#39;weights.mb&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params_dict</span> <span class="o">=</span> <span class="n">old_params</span>

        <span class="n">trn_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stats</span><span class="p">]</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">),</span>
                    <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                    <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

        <span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;analytic correction for proposal seemingly failed!&#39;</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">logs</span><span class="p">,</span> <span class="n">trn_datasets</span><span class="p">,</span> <span class="n">posteriors</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_repeated" id="run_repeated"><em>SNPEA</em>.<strong>run_repeated</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Repeatedly run the method and collect results. Optionally, carry out
several runs with the same initial generator RNG state but different
neural network initializations.

parameters
----------
n_repeats : int
    Number of times to run the algorithm
n_NN_inits : int
    Number of times to
callback: function
    callback function that will be called after each run. It should
    take 4 inputs: callback(log, train_data, posterior, self)
kwargs : additional keyword arguments
    Additional arguments that will be passed to the run() method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_repeated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">generator_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_NN_inits_per_repeat</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">generator_seed</span><span class="p">)</span>

            <span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
            <span class="n">repeat_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="standardize_init" id="standardize_init"><em>SNPEA</em>.<strong>standardize_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Standardizes the network initialization on obs

Ensures output distributions for xo have mean zero and unit variance.
Alters hidden layers to propagates x=xo as zero to the last layer, and
alters the MoG layers to produce the desired output distribution.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">standardize_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>

    <span class="c1"># ensure x&#39; = x - xo</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">centre_on_obs</span><span class="p">()</span>

    <span class="c1"># ensure x&#39; = 0 stays zero up to MoG layer (setting biases to zero)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">remove_hidden_biases</span><span class="p">()</span>

    <span class="c1"># ensure MoG returns standardized output on x&#39; = 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">conditional_norm</span><span class="p">(</span><span class="n">fcv</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h2 id="SNPEB"><strong>SNPEB</strong><code class="codehilite"><span class="k">class</span></code><a class="headerlink" href="#SNPEB" title="Permanent link">&para;</a></h2>
<h3 data-toc-label="__init__" id="__init__"><em>SNPEB</em>.<strong>__init__</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">convert_to_T</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>SNPE-B

Implementation of Lueckmann, Goncalves, Bassetto, Öcal, Nonnenmacher &amp; Macke (NeurIPS 2017)

Parameters
----------
generator : generator instance
    Generator instance
obs : array
    Observation in the format the generator returns (1 x n_summary)
prior_norm : bool
    If set to True, will z-transform params based on mean/std of prior
pilot_samples : None or int
    If an integer is provided, a pilot run with the given number of
    samples is run. The mean and std of the summary statistics of the
    pilot samples will be subsequently used to z-transform summary
    statistics.
convert_to_T : None or int
    Convert proposal distribution to Student&#39;s T? If a number if given,
    the number specifies the degrees of freedom. None for no conversion
reg_lambda : float
    Precision parameter for weight regularizer if svi is True
prior_mixin : float
    Percentage of the prior mixed into the proposal prior. While training,
    an additional prior_mixin * N samples will be drawn from the actual prior
    in each round.
seed : int or None
    If provided, random number generator will be seeded
verbose : bool
    Controls whether or not progressbars are shown
kwargs : additional keyword arguments
    Additional arguments for the NeuralNet instance, including:
        n_components : int
            Number of components of the mixture density
        n_hiddens : list of ints
            Number of hidden units per layer of the neural network
        svi : bool
            Whether to use SVI version of the network or not

Attributes
----------
observables : dict
    Dictionary containing theano variables that can be monitored while
    training the neural network.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="n">convert_to_T</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;SNPE requires observed data&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="n">prior_norm</span><span class="p">,</span>
                     <span class="n">pilot_samples</span><span class="o">=</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observed data contains NaNs&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_T</span> <span class="o">=</span> <span class="n">convert_to_T</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">prior_mixin</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">prior_mixin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prior_mixin</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="centre_on_obs" id="centre_on_obs"><em>SNPEB</em>.<strong>centre_on_obs</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Centres first-layer input onto observed summary statistics

Ensures x&#39; = x - xo, i.e. first-layer input x&#39; = 0 for x = xo.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">centre_on_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>


    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="compile_observables" id="compile_observables"><em>SNPEB</em>.<strong>compile_observables</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Creates observables dict
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile_observables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">aps</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="conditional_norm" id="conditional_norm"><em>SNPEB</em>.<strong>conditional_norm</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Normalizes current network output at observed summary statistics

Parameters
----------
fcv : float
    Fraction of total that comes from uncertainty over components, i.e.
    Var[th] = E[Var[th|z]] + Var[E[th|z]]
            =  (1-fcv)     +     fcv       = 1
tmu: array
    Target mean.
tSig: array
    Target covariance.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">conditional_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


    <span class="c1"># avoid CDELFI.predict() attempt to analytically correct for proposal</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">obz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_mog</span><span class="p">(</span><span class="n">obz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                     <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mog</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># assumes uniform alpha</span>

    <span class="n">n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">]</span>
    <span class="n">triu_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diag_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># compute MoG mean mu, Sig = E[Var[th|z]] and C = Var[E[th|z]]</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">Sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">Sig</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">S</span>
        <span class="n">mu</span>  <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">mu</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> \
            <span class="k">else</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dmu</span><span class="p">,</span> <span class="n">dmu</span><span class="p">)</span>

    <span class="c1"># if not provided, target zero-mean unit variance (as for prior_norm=True)</span>
    <span class="n">tmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmu</span>
    <span class="n">tSig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">tSig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tSig</span>

    <span class="c1"># compute normalizers (we only z-score, don&#39;t whiten!)</span>
    <span class="n">Z1inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">fcv</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Z2inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">fcv</span>    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># first we need the center of means</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;means&#39;</span>
    <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h</span>
        <span class="n">mu_</span> <span class="o">+=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">mu_</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># center and normalize means</span>
    <span class="c1"># mu =  Z2inv * (Wh + b - mu_) + tmu</span>
    <span class="c1">#    = Wh + (Z2inv * (b - mu_ + Wh) - Wh + tum)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">Z2inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">Wh</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">-</span> <span class="n">mu_</span><span class="p">)</span> <span class="o">-</span> <span class="n">Wh</span> <span class="o">+</span> <span class="n">tmu</span><span class="p">)</span>

    <span class="c1"># normalize covariances</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;precisions&#39;</span>
    <span class="c1"># Sig^-0.5 = diag_mask * (exp(Wh+b)/exp(log(Z1)) + triu_mask * (Wh+b)*Z1</span>
    <span class="c1">#          = diag_mask *  exp(Wh+ (b-log(Z1))    + triu_mask * (Wh+((b+Wh)*Z1-Wh))</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">diag_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z1inv</span><span class="p">)))</span> <span class="o">+</span> <span class="n">triu_mask</span> <span class="o">*</span> <span class="p">((</span><span class="n">b_</span><span class="o">+</span><span class="n">Wh</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">Z1inv</span><span class="p">))</span><span class="o">-</span> <span class="n">Wh</span> <span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen" id="gen"><em>SNPEB</em>.<strong>gen</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate from generator and z-transform

Parameters
----------
n_samples : int
    Number of samples to generate
n_reps : int
    Number of repeats per parameter
verbose : None or bool or str
    If None is passed, will default to self.verbose
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">n_reps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;n_reps &gt; 1 is not yet supported&#39;</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">verbose</span>

    <span class="n">n_pilot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">n_pilot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">:</span>  <span class="c1"># reuse pilot samples</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">n_pilot</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:],</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n_pilot</span><span class="p">:,</span> <span class="p">:])</span>
        <span class="n">n_samples</span> <span class="o">-=</span> <span class="n">n_pilot</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">params_rem</span><span class="p">,</span> <span class="n">stats_rem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                                       <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">params</span><span class="p">,</span> <span class="n">params_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">stats</span><span class="p">,</span> <span class="n">stats_rem</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span>
                                           <span class="n">prior_mixin</span><span class="o">=</span><span class="n">prior_mixin</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># z-transform params and stats</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>

    <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">stats</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen_newseed" id="gen_newseed"><em>SNPEB</em>.<strong>gen_newseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generates a new random seed
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen_newseed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="loss" id="loss"><em>SNPEB</em>.<strong>loss</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Loss function for training

Parameters
----------
N : int
    Number of training samples
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_loss</span><span class="p">()</span>

    <span class="c1"># adding nodes to dict s.t. they can be monitored during training</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.iws&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">iws</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.raw_loss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loss</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&lt;=</span> <span class="n">round_cl</span><span class="p">:</span>
            <span class="c1"># weights close to zero-centered prior in the first round</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># weights close to those of previous round</span>
            <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">kl</span>

        <span class="c1"># adding nodes to dict s.t. they can be monitored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.kl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">imvs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="monitor_dict_from_names" id="monitor_dict_from_names"><em>SNPEB</em>.<strong>monitor_dict_from_names</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate monitor dict from list of variable names
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">monitor_dict_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">monitor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">monitor</span> <span class="o">=</span> <span class="p">[</span><span class="n">monitor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monitor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>
                <span class="n">observe</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">observe</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="norm_init" id="norm_init"><em>SNPEB</em>.<strong>norm_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">norm_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_norm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;standardizing network initialization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_fcv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="pilot_run" id="pilot_run"><em>SNPEB</em>.<strong>pilot_run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Pilot run in order to find parameters for z-scoring stats
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pilot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">pilot_samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pilot_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">):</span>  <span class="c1"># determine via pilot run</span>
        <span class="k">assert</span> <span class="n">pilot_samples</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># reseed generator for consistent inits</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(pilot run) &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># samples were provided as an input</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">pilot_samples</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">,</span> <span class="n">min_std</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="n">ok_sims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:],</span> <span class="n">stats</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="predict" id="predict"><em>SNPEB</em>.<strong>predict</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Predict posterior given x

Parameters
----------
x : array
    Stats for which to compute the posterior
deterministic : bool
    if True, mean weights are used for Bayesian network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>
    <span class="c1"># z-transform inputs</span>
    <span class="n">x_zt</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>

    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_density</span><span class="p">(</span><span class="n">x_zt</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">)</span>

    <span class="c1"># z-transform outputs</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;maf&#39;</span><span class="p">:</span>
        <span class="n">posterior</span><span class="o">.</span><span class="n">set_scale_and_offset</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">,</span>
                                       <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_std</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posterior</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reinit_network" id="reinit_network"><em>SNPEB</em>.<strong>reinit_network</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Reinitializes the network instance (re-setting the weights!)
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reinit_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">NeuralNet</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">svi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">svi</span> <span class="k">if</span> <span class="s1">&#39;svi&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">update</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="n">so</span> <span class="n">that</span> <span class="n">reinitializing</span> <span class="n">the</span> <span class="n">network</span> <span class="n">gives</span> <span class="n">a</span>
    <span class="n">different</span> <span class="n">result</span> <span class="n">each</span> <span class="n">time</span> <span class="n">unless</span> <span class="n">we</span> <span class="n">reseed</span> <span class="n">the</span> <span class="n">inference</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">norm_init</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="remove_hidden_biases" id="remove_hidden_biases"><em>SNPEB</em>.<strong>remove_hidden_biases</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets all bias weights in hidden layers to zero.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_hidden_biases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">idx_hiddens</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">idx_hiddens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">):</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reseed" id="reseed"><em>SNPEB</em>.<strong>reseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>reseed inference method&#39;s RNG, then generator, then network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reseed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>   <span class="c1"># for consistent NN init</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># also reseeds prior + model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># for reproducible samples</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reset" id="reset"><em>SNPEB</em>.<strong>reset</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets inference method to a naive state, before it has seen any
real or simulated data. The following happens, in order:
1) The generator&#39;s proposal is set to None, and self.round is set to 0
2) The inference method is reseeded if a seed is provided
3) The network is reinitialized
4) Any additional resetting of state specific to each inference method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reinit_network</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run" id="run"><em>SNPEB</em>.<strong>run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Run algorithm

Parameters
----------
n_train : int or list of ints
    Number of data points drawn per round. If a list is passed, the
    nth list element specifies the number of training examples in the
    nth round. If there are fewer list elements than rounds, the last
    list element is used.
n_rounds : int
    Number of rounds
epochs : int
    Number of epochs used for neural network training
minibatch : int
    Size of the minibatches used for neural network training
monitor : list of str
    Names of variables to record during training along with the value
    of the loss function. The observables attribute contains all
    possible variables that can be monitored
round_cl : int
    Round after which to start continual learning
stop_on_nan : bool
    If True, will halt if NaNs in the loss are encountered
proposal : Distribution of None
    If given, will use this distribution as the starting proposal prior
kwargs : additional keyword arguments
    Additional arguments for the Trainer instance

Returns
-------
logs : list of dicts
    Dictionaries contain information logged while training the networks
trn_datasets : list of (params, stats)
    training datasets, z-transformed
posteriors : list of distributions
    posterior after each round
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span>
69
<span class="special">70</span>
71
<span class="special">72</span>
73
<span class="special">74</span>
75
<span class="special">76</span>
77
<span class="special">78</span>
79
<span class="special">80</span>
81
<span class="special">82</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trn_datasets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">posteriors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="c1"># if round &gt; 1, set new proposal distribution before sampling</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># posterior becomes new proposal prior</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>  <span class="c1"># see super</span>

            <span class="c1"># convert proposal to student&#39;s T?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_to_T</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="n">dofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dofs</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span><span class="o">.</span><span class="n">convert_to_T</span><span class="p">(</span><span class="n">dofs</span><span class="o">=</span><span class="n">dofs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>

        <span class="c1"># number of training examples for this round</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span>


        <span class="c1"># draw training data (z-transformed params and stats)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(round </span><span class="si">{}</span><span class="s1">) &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">trn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">prior_mixin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_mixin</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># precompute importance weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span> <span class="o">*</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span>
            <span class="n">p_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">p_proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">iws</span> <span class="o">=</span> <span class="n">p_prior</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_mixin</span> <span class="o">*</span> <span class="n">p_prior</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_mixin</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_proposal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_train_round</span><span class="p">,))</span>

        <span class="c1"># normalize weights</span>
        <span class="n">iws</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">iws</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iws</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">trn_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">trn_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">iws</span><span class="p">)</span>
        <span class="n">trn_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">iws</span><span class="p">]</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">),</span>
                    <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                    <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                    <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="n">stop_on_nan</span><span class="p">))</span>

        <span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot predict posterior after round </span><span class="si">{}</span><span class="s2"> due to NaNs&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">logs</span><span class="p">,</span> <span class="n">trn_datasets</span><span class="p">,</span> <span class="n">posteriors</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_repeated" id="run_repeated"><em>SNPEB</em>.<strong>run_repeated</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Repeatedly run the method and collect results. Optionally, carry out
several runs with the same initial generator RNG state but different
neural network initializations.

parameters
----------
n_repeats : int
    Number of times to run the algorithm
n_NN_inits : int
    Number of times to
callback: function
    callback function that will be called after each run. It should
    take 4 inputs: callback(log, train_data, posterior, self)
kwargs : additional keyword arguments
    Additional arguments that will be passed to the run() method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_repeated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">generator_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_NN_inits_per_repeat</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">generator_seed</span><span class="p">)</span>

            <span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
            <span class="n">repeat_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="standardize_init" id="standardize_init"><em>SNPEB</em>.<strong>standardize_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Standardizes the network initialization on obs

Ensures output distributions for xo have mean zero and unit variance.
Alters hidden layers to propagates x=xo as zero to the last layer, and
alters the MoG layers to produce the desired output distribution.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">standardize_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>

    <span class="c1"># ensure x&#39; = x - xo</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">centre_on_obs</span><span class="p">()</span>

    <span class="c1"># ensure x&#39; = 0 stays zero up to MoG layer (setting biases to zero)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">remove_hidden_biases</span><span class="p">()</span>

    <span class="c1"># ensure MoG returns standardized output on x&#39; = 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">conditional_norm</span><span class="p">(</span><span class="n">fcv</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h2 id="SNPEC"><strong>SNPEC</strong><code class="codehilite"><span class="k">class</span></code><a class="headerlink" href="#SNPEC" title="Permanent link">&para;</a></h2>
<h3 data-toc-label="__init__" id="__init__"><em>SNPEC</em>.<strong>__init__</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_prior_precision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Ptol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>SNPE-C/APT

Implementation of Greenberg, Nonnenmacher &amp; Macke (ICML 2019)

Parameters
----------
generator : generator instance
    Generator instance
obs : array
    Observation in the format the generator returns (1 x n_summary)
prior_norm : bool
    If set to True, will z-transform params based on mean/std of prior
pilot_samples : None or int
    If an integer is provided, a pilot run with the given number of
    samples is run. The mean and std of the summary statistics of the
    pilot samples will be subsequently used to z-transform summary
    statistics.
n_components : int
    Number of components in final round (PM&#39;s algorithm 2)
reg_lambda : float
    Precision parameter for weight regularizer if svi is True
seed : int or None
    If provided, random number generator will be seeded
verbose : bool
    Controls whether or not progressbars are shown
add_prior_precision: bool
    Whether to add the prior precision to each posterior component for Gauss/MoG proposals
Ptol: float
    Quantity added to the diagonal entries of the precision matrix for each Gaussian posterior component
kwargs : additional keyword arguments
    Additional arguments for the NeuralNet instance, including:
        n_hiddens : list of ints
            Number of hidden units per layer of the neural network
        svi : bool
            Whether to use SVI version of the network or not

Attributes
----------
observables : dict
    Dictionary containing theano variables that can be monitored while
    training the neural network.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">pilot_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">add_prior_precision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Ptol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">assert</span> <span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;APT requires observed data&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">prior_norm</span><span class="o">=</span><span class="n">prior_norm</span><span class="p">,</span>
                     <span class="n">pilot_samples</span><span class="o">=</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># initializes network</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observed data contains NaNs&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">Ptol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="k">if</span> <span class="n">Ptol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Ptol</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_prior_precision</span> <span class="o">=</span> <span class="n">add_prior_precision</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">exception_info</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="centre_on_obs" id="centre_on_obs"><em>SNPEC</em>.<strong>centre_on_obs</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Centres first-layer input onto observed summary statistics

Ensures x&#39; = x - xo, i.e. first-layer input x&#39; = 0 for x = xo.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">centre_on_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>


    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="compile_observables" id="compile_observables"><em>SNPEC</em>.<strong>compile_observables</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Creates observables dict
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile_observables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">aps</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="conditional_norm" id="conditional_norm"><em>SNPEC</em>.<strong>conditional_norm</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Normalizes current network output at observed summary statistics

Parameters
----------
fcv : float
    Fraction of total that comes from uncertainty over components, i.e.
    Var[th] = E[Var[th|z]] + Var[E[th|z]]
            =  (1-fcv)     +     fcv       = 1
tmu: array
    Target mean.
tSig: array
    Target covariance.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59
<span class="special">60</span>
61
<span class="special">62</span>
63
<span class="special">64</span>
65
<span class="special">66</span>
67
<span class="special">68</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">conditional_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">tmu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tSig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


    <span class="c1"># avoid CDELFI.predict() attempt to analytically correct for proposal</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">obz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">get_mog</span><span class="p">(</span><span class="n">obz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                     <span class="n">deterministic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mog</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">ztrans_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span> <span class="c1"># assumes uniform alpha</span>

    <span class="n">n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_outputs&#39;</span><span class="p">]</span>
    <span class="n">triu_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diag_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># compute MoG mean mu, Sig = E[Var[th|z]] and C = Var[E[th|z]]</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">Sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">Sig</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">S</span>
        <span class="n">mu</span>  <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">):</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="n">mu</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> \
            <span class="k">else</span> <span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">m</span>
        <span class="n">C</span> <span class="o">+=</span> <span class="n">mog</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dmu</span><span class="p">,</span> <span class="n">dmu</span><span class="p">)</span>

    <span class="c1"># if not provided, target zero-mean unit variance (as for prior_norm=True)</span>
    <span class="n">tmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">tmu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmu</span>
    <span class="n">tSig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">tSig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tSig</span>

    <span class="c1"># compute normalizers (we only z-score, don&#39;t whiten!)</span>
    <span class="n">Z1inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">fcv</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Sig</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Z2inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">fcv</span>    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tSig</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># first we need the center of means</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;means&#39;</span>
    <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mog</span><span class="o">.</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h</span>
        <span class="n">mu_</span> <span class="o">+=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
    <span class="n">mu_</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># center and normalize means</span>
    <span class="c1"># mu =  Z2inv * (Wh + b - mu_) + tmu</span>
    <span class="c1">#    = Wh + (Z2inv * (b - mu_ + Wh) - Wh + tum)</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">Z2inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">Wh</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">-</span> <span class="n">mu_</span><span class="p">)</span> <span class="o">-</span> <span class="n">Wh</span> <span class="o">+</span> <span class="n">tmu</span><span class="p">)</span>

    <span class="c1"># normalize covariances</span>
    <span class="k">def</span> <span class="nf">idx_MoG</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;precisions&#39;</span>
    <span class="c1"># Sig^-0.5 = diag_mask * (exp(Wh+b)/exp(log(Z1)) + triu_mask * (Wh+b)*Z1</span>
    <span class="c1">#          = diag_mask *  exp(Wh+ (b-log(Z1))    + triu_mask * (Wh+((b+Wh)*Z1-Wh))</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_wp</span><span class="p">),</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="n">idx_MoG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">)):</span>
        <span class="n">Wh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span><span class="n">n_dim</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">diag_mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z1inv</span><span class="p">)))</span> <span class="o">+</span> <span class="n">triu_mask</span> <span class="o">*</span> <span class="p">((</span><span class="n">b_</span><span class="o">+</span><span class="n">Wh</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">Z1inv</span><span class="p">))</span><span class="o">-</span> <span class="n">Wh</span> <span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="define_loss" id="define_loss"><em>SNPEC</em>.<strong>define_loss</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">combined_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Loss function for training

Parameters
----------
n : int
    Number of training samples
round_cl : int
    Round after which to start continual learning
proposal : str
    Specifier for type of proposal used: continuous (&#39;gaussian&#39;, &#39;mog&#39;)
    or &#39;atomic&#39; proposals are implemented.
combined_loss : bool
    Whether to include prior likelihood terms in addition to atomic
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">define_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                <span class="n">combined_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">MoG</span><span class="p">):</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">ztrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;prior&#39;</span><span class="p">:</span>  <span class="c1"># using prior as proposal</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="n">snpe_loss_prior_as_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">svi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">)</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="n">apt_loss_gaussian_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">svi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">,</span>
                                                      <span class="n">add_prior_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_prior_precision</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">MoG</span><span class="p">)</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="n">apt_loss_MoG_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">svi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">,</span>
                                                 <span class="n">add_prior_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_prior_precision</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;atomic&#39;</span><span class="p">:</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> \
            <span class="n">apt_loss_atomic_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">svi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">,</span> <span class="n">combined_loss</span><span class="o">=</span><span class="n">combined_loss</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">()</span>

    <span class="c1"># adding nodes to dict s.t. they can be monitored during training</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.lprobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">lprobs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.raw_loss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loss</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">svi</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&lt;=</span> <span class="n">round_cl</span><span class="p">:</span>
            <span class="c1"># weights close to zero-centered prior in the first round</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># weights close to those of previous round</span>
            <span class="n">kl</span><span class="p">,</span> <span class="n">imvs</span> <span class="o">=</span> <span class="n">svi_kl_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">sps</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">kl</span>

        <span class="c1"># adding nodes to dict s.t. they can be monitored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="s1">&#39;loss.kl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">imvs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="epochs_round" id="epochs_round"><em>SNPEC</em>.<strong>epochs_round</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">epochs_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
    <span class="c1"># number of training examples for this round</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">epochs_round</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">epochs_round</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">epochs_round</span> <span class="o">=</span> <span class="n">epochs</span>

    <span class="k">return</span> <span class="n">epochs_round</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen" id="gen"><em>SNPEC</em>.<strong>gen</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="p">,</span> <span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate from generator and z-transform

Parameters
----------
n_samples : int
    Number of samples to generate
n_reps : int
    Number of repeats per parameter
verbose : None or bool or str
    If None is passed, will default to self.verbose
project_to_gaussian: bool
    Whether to always return Gaussian objects (instead of MoG)
n_train: int
    Number of training samples
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="p">,</span> <span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(round </span><span class="si">{}</span><span class="s1">) &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">n_train_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_train_round</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span>

    <span class="n">trn_data</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># may have decreased (rejection)</span>

    <span class="k">return</span> <span class="n">trn_data</span><span class="p">,</span> <span class="n">n_train_round</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="gen_newseed" id="gen_newseed"><em>SNPEC</em>.<strong>gen_newseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generates a new random seed
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen_newseed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="loss" id="loss"><em>SNPEC</em>.<strong>loss</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="monitor_dict_from_names" id="monitor_dict_from_names"><em>SNPEC</em>.<strong>monitor_dict_from_names</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Generate monitor dict from list of variable names
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">monitor_dict_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">monitor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">monitor</span> <span class="o">=</span> <span class="p">[</span><span class="n">monitor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monitor</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">:</span>
                <span class="n">observe</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">observe</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">observe</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="n_train_round" id="n_train_round"><em>SNPEC</em>.<strong>n_train_round</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">n_train_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="p">):</span>
    <span class="c1"># number of training examples for this round</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">n_train</span>

    <span class="k">return</span> <span class="n">n_train_round</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="norm_init" id="norm_init"><em>SNPEC</em>.<strong>norm_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">norm_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_norm</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;standardizing network initialization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_fcv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_init</span><span class="p">(</span><span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="pilot_run" id="pilot_run"><em>SNPEC</em>.<strong>pilot_run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Pilot run in order to find parameters for z-scoring stats
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pilot_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_samples</span><span class="p">,</span> <span class="n">n_stats</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">pilot_samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pilot_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_stats</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">isint</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">):</span>  <span class="c1"># determine via pilot run</span>
        <span class="k">assert</span> <span class="n">pilot_samples</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># reseed generator for consistent inits</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="s1">&#39;(pilot run) &#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">pilot_samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># samples were provided as an input</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">pilot_samples</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">,</span> <span class="n">min_std</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;pilot run failed&quot;</span>
    <span class="n">ok_sims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unused_pilot_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:],</span> <span class="n">stats</span><span class="p">[</span><span class="n">ok_sims</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="predict" id="predict"><em>SNPEC</em>.<strong>predict</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Predict posterior given x

Parameters
----------
x : array
    Stats for which to compute the posterior
deterministic : bool
    if True, mean weights are used for Bayesian network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;mog&#39;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">MoG</span><span class="p">)</span>
        <span class="n">P_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ptol</span>
        <span class="c1"># add the prior precision to each posterior component if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_prior_precision</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">):</span>
            <span class="n">P_offset</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">P</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">MoG</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="o">=</span><span class="p">[</span><span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">P</span> <span class="o">+</span> <span class="n">P_offset</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">xs</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reinit_network" id="reinit_network"><em>SNPEC</em>.<strong>reinit_network</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Reinitializes the network instance (re-setting the weights!)
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reinit_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">NeuralNet</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">svi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">svi</span> <span class="k">if</span> <span class="s1">&#39;svi&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">update</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="n">so</span> <span class="n">that</span> <span class="n">reinitializing</span> <span class="n">the</span> <span class="n">network</span> <span class="n">gives</span> <span class="n">a</span>
    <span class="n">different</span> <span class="n">result</span> <span class="n">each</span> <span class="n">time</span> <span class="n">unless</span> <span class="n">we</span> <span class="n">reseed</span> <span class="n">the</span> <span class="n">inference</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">norm_init</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="remove_hidden_biases" id="remove_hidden_biases"><em>SNPEC</em>.<strong>remove_hidden_biases</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets all bias weights in hidden layers to zero.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_hidden_biases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">idx_hiddens</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">idx_hiddens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">mps_bp</span><span class="p">):</span>
        <span class="n">b</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reseed" id="reseed"><em>SNPEC</em>.<strong>reseed</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>reseed inference method&#39;s RNG, then generator, then network
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3
<span class="special">4</span>
5
<span class="special">6</span>
7
<span class="special">8</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reseed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>   <span class="c1"># for consistent NN init</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># also reseeds prior + model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">())</span>  <span class="c1"># for reproducible samples</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="reset" id="reset"><em>SNPEC</em>.<strong>reset</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Resets inference method to a naive state, before it has seen any
real or simulated data. The following happens, in order:
1) The generator&#39;s proposal is set to None, and self.round is set to 0
2) The inference method is reseeded if a seed is provided
3) The network is reinitialized
4) Any additional resetting of state specific to each inference method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
<span class="special">2</span>
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run" id="run"><em>SNPEC</em>.<strong>run</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">silent_fail</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Run algorithm

Parameters
----------
n_train : int or list of ints
    Number of data points drawn per round. If a list is passed, the
    nth list element specifies the number of training examples in the
    nth round. If there are fewer list elements than rounds, the last
    list element is used.
n_rounds : int
    Number of rounds
proposal : str
    Specifier for type of proposal used: continuous (&#39;gaussian&#39;, &#39;mog&#39;)
    or &#39;atomic&#39; proposals are implemented.
epochs : int
    Number of epochs used for neural network training
minibatch : int
    Size of the minibatches used for neural network training
monitor : list of str
    Names of variables to record during training along with the value
    of the loss function. The observables attribute contains all
    possible variables that can be monitored
round_cl : int
    Round after which to start continual learning
stop_on_nan : bool
    If True, will halt if NaNs in the loss are encountered
silent_fail : bool
    If true, will continue without throwing an error when a round fails
kwargs : additional keyword arguments
    Additional arguments for the Trainer instance

Returns
-------
logs : list of dicts
    Dictionaries contain information logged while training the networks
trn_datasets : list of (params, stats)
    training datasets, z-transformed
posteriors : list of distributions
    posterior after each round
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">silent_fail</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># support &#39;discrete&#39; instead of &#39;atomic&#39; for backwards compatibility</span>
    <span class="k">if</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;discrete&#39;</span><span class="p">:</span>
        <span class="n">proposal</span> <span class="o">=</span> <span class="s1">&#39;atomic&#39;</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;discrete_comb&#39;</span><span class="p">:</span>
        <span class="n">proposal</span> <span class="o">=</span> <span class="s1">&#39;atomic_comb&#39;</span>

    <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trn_datasets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">posteriors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="s1">&#39;train_on_all&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;train_on_all&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;round_cl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> \
                <span class="s1">&#39;reuse_prior_samples&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># prevent numerical instability (broad unused comps)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reuse_prior_samples&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">silent_fail</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_round</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Round </span><span class="si">{0}</span><span class="s1"> failed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">))</span>
                <span class="kn">import</span> <span class="nn">sys</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exception_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_round</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
        <span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>
        <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">logs</span><span class="p">,</span> <span class="n">trn_datasets</span><span class="p">,</span> <span class="n">posteriors</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_MoG" id="run_MoG"><em>SNPEC</em>.<strong>run_MoG</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_MoG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># simulate data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_proposal</span><span class="p">(</span><span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">MoG</span><span class="p">)</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">ztrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="n">trn_data</span><span class="p">,</span> <span class="n">n_train_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span>
    <span class="n">trn_data</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">trn_data</span><span class="p">,</span> <span class="o">*</span><span class="n">MoG_prop_APT_training_vars</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">n_train_round</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">n_components</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">train_on_all</span><span class="p">:</span>
        <span class="n">prev_datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
                <span class="n">prev_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span> <span class="o">==</span> <span class="s1">&#39;prior&#39;</span> <span class="ow">and</span> <span class="n">reuse_prior_samples</span><span class="p">:</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Uniform</span><span class="p">):</span>
                    <span class="n">prior</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">ztrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">MoG_prop_APT_training_vars</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">n_train_round</span><span class="p">))</span>
                <span class="n">prev_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">prop_m</span><span class="p">,</span> <span class="n">prop_P</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">prop_m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">prop_P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">continue</span>  <span class="c1"># reusing samples with proposals that changed within a round is not yet supported</span>
                <span class="n">prop</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">prop_m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="o">=</span><span class="n">prop_P</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="o">*</span><span class="n">MoG_prop_APT_training_vars</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">n_train_round</span><span class="p">))</span>
                <span class="n">prev_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># can&#39;t re-use samples from this proposal</span>
                <span class="k">continue</span>

        <span class="n">trn_data</span> <span class="o">=</span> <span class="n">combine_trn_datasets</span><span class="p">(</span><span class="n">prev_datasets</span><span class="p">)</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_loss</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;mog&#39;</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs_round</span><span class="p">(</span><span class="n">epochs</span><span class="p">),</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                  <span class="n">print_each_epoch</span><span class="o">=</span><span class="n">print_each_epoch</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="n">stop_on_nan</span><span class="p">,</span>
                  <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="n">monitor_every</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_atomic" id="run_atomic"><em>SNPEC</em>.<strong>run_atomic</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="s1">&#39;resample&#39;</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combined_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="s1">&#39;resample&#39;</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">combined_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># activetrainer doesn&#39;t de-norm params before evaluating the prior</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_std</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">),</span> <span class="s2">&quot;prior_norm + atomic not supported&quot;</span>

    <span class="k">assert</span> <span class="n">minibatch</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;minimum minibatch size 2 for atomic proposals&quot;</span>
    <span class="k">if</span> <span class="n">n_atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">minibatch</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">minibatch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_atoms</span> <span class="o">&lt;</span> <span class="n">minibatch</span><span class="p">,</span> <span class="s2">&quot;Minibatch too small for this many atoms&quot;</span>
    <span class="c1"># simulate data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_proposal</span><span class="p">()</span>
    <span class="n">trn_data</span><span class="p">,</span> <span class="n">n_train_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>  <span class="c1"># don&#39;t store prior_masks</span>

    <span class="k">if</span> <span class="n">train_on_all</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reuse_prior_samples</span><span class="p">:</span>
            <span class="n">trn_data</span> <span class="o">=</span> <span class="n">combine_trn_datasets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">,</span> <span class="n">max_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trn_data</span> <span class="o">=</span> <span class="n">combine_trn_datasets</span><span class="p">(</span>
                <span class="p">[</span><span class="n">td</span> <span class="k">for</span> <span class="n">td</span><span class="p">,</span> <span class="n">pu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">)</span> <span class="k">if</span> <span class="n">pu</span> <span class="o">!=</span> <span class="s1">&#39;prior&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">combined_loss</span><span class="p">:</span>
            <span class="n">prior_masks</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">td</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pu</span> <span class="o">==</span> <span class="s1">&#39;prior&#39;</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">td</span><span class="p">,</span> <span class="n">pu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">)]</span>
            <span class="n">trn_data</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">prior_masks</span><span class="p">))</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># train network</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_loss</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span>
                                             <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">,</span>
                                             <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;atomic&#39;</span><span class="p">,</span>
                                             <span class="n">combined_loss</span><span class="o">=</span><span class="n">combined_loss</span> <span class="ow">and</span> <span class="n">train_on_all</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">ActiveTrainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                      <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                      <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                      <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                      <span class="n">generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">,</span>
                      <span class="n">n_atoms</span><span class="o">=</span><span class="n">n_atoms</span><span class="p">,</span>
                      <span class="n">moo</span><span class="o">=</span><span class="n">moo</span><span class="p">,</span>
                      <span class="n">obs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats_std</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs_round</span><span class="p">(</span><span class="n">epochs</span><span class="p">),</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                  <span class="n">print_each_epoch</span><span class="o">=</span><span class="n">print_each_epoch</span><span class="p">,</span> <span class="n">strict_batch_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="n">monitor_every</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_gaussian" id="run_gaussian"><em>SNPEC</em>.<strong>run_gaussian</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span>
33
<span class="special">34</span>
35
<span class="special">36</span>
37
<span class="special">38</span>
39
<span class="special">40</span>
41
<span class="special">42</span>
43
<span class="special">44</span>
45
<span class="special">46</span>
47
<span class="special">48</span>
49
<span class="special">50</span>
51
<span class="special">52</span>
53
<span class="special">54</span>
55
<span class="special">56</span>
57
<span class="special">58</span>
59</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># simulate data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_proposal</span><span class="p">(</span><span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">)</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">ztrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>

    <span class="n">trn_data</span><span class="p">,</span> <span class="n">n_train_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span>

    <span class="n">prop_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">prop_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n_train_round</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">trn_data</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">prop_m</span><span class="p">,</span> <span class="n">prop_P</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">train_on_all</span><span class="p">:</span>
        <span class="n">prev_datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
                <span class="n">prev_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;prior&#39;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reuse_prior_samples</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># prior samples. the Gauss loss will reduce to the prior loss</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">):</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">ztrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_std</span><span class="p">)</span>
                <span class="n">prop_m</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">mean</span>
                <span class="n">prop_P</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">P</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">Uniform</span><span class="p">):</span>
                <span class="c1"># model a uniform as an zero-precision Gaussian:</span>
                <span class="n">prop_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="n">prop_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># can&#39;t reuse prior samples unless prior is uniform or Gaussian</span>
                <span class="k">continue</span>
            <span class="n">prop_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">prop_m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prop_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">prop_P</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">prev_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">prop_m</span><span class="p">,</span> <span class="n">prop_P</span><span class="p">))</span>

        <span class="n">trn_data</span> <span class="o">=</span> <span class="n">combine_trn_datasets</span><span class="p">(</span><span class="n">prev_datasets</span><span class="p">)</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># train network</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_loss</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span>
                                             <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">,</span>
                                             <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">log</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs_round</span><span class="p">(</span><span class="n">epochs</span><span class="p">),</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                  <span class="n">print_each_epoch</span><span class="o">=</span><span class="n">print_each_epoch</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="n">stop_on_nan</span><span class="p">,</span>
                  <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="n">monitor_every</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_prior" id="run_prior"><em>SNPEC</em>.<strong>run_prior</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25
<span class="special">26</span>
27
<span class="special">28</span>
29
<span class="special">30</span>
31
<span class="special">32</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_train</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minibatch</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">moo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_on_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">round_cl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop_on_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">patience</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reuse_prior_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># simulate data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">prior</span>
    <span class="n">trn_data</span><span class="p">,</span> <span class="n">n_train_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">n_train</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trn_data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">train_on_all</span> <span class="ow">and</span> <span class="n">reuse_prior_samples</span><span class="p">:</span>
        <span class="n">prior_datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trn_datasets</span><span class="p">)</span>
                          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;prior&#39;</span><span class="p">]</span>
        <span class="n">trn_data</span> <span class="o">=</span> <span class="n">combine_trn_datasets</span><span class="p">(</span><span class="n">prior_datasets</span><span class="p">)</span>
        <span class="n">n_train_round</span> <span class="o">=</span> <span class="n">trn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># train network</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">trn_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_loss</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_train_round</span><span class="p">,</span>
                                             <span class="n">round_cl</span><span class="o">=</span><span class="n">round_cl</span><span class="p">,</span>
                                             <span class="n">proposal</span><span class="o">=</span><span class="s1">&#39;prior&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span>
                <span class="n">trn_data</span><span class="o">=</span><span class="n">trn_data</span><span class="p">,</span> <span class="n">trn_inputs</span><span class="o">=</span><span class="n">trn_inputs</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">(),</span>
                <span class="n">monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">monitor_dict_from_names</span><span class="p">(</span><span class="n">monitor</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs_round</span><span class="p">(</span><span class="n">epochs</span><span class="p">),</span> <span class="n">minibatch</span><span class="o">=</span><span class="n">minibatch</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">print_each_epoch</span><span class="o">=</span><span class="n">print_each_epoch</span><span class="p">,</span>
                  <span class="n">stop_on_nan</span><span class="o">=</span><span class="n">stop_on_nan</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">monitor_every</span><span class="o">=</span><span class="n">monitor_every</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log</span><span class="p">,</span> <span class="n">trn_data</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_repeated" id="run_repeated"><em>SNPEC</em>.<strong>run_repeated</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Repeatedly run the method and collect results. Optionally, carry out
several runs with the same initial generator RNG state but different
neural network initializations.

parameters
----------
n_repeats : int
    Number of times to run the algorithm
n_NN_inits : int
    Number of times to
callback: function
    callback function that will be called after each run. It should
    take 4 inputs: callback(log, train_data, posterior, self)
kwargs : additional keyword arguments
    Additional arguments that will be passed to the run() method
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17
<span class="special">18</span>
19
<span class="special">20</span>
21
<span class="special">22</span>
23
<span class="special">24</span>
25</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_repeated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_NN_inits_per_repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">generator_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_newseed</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_NN_inits_per_repeat</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_NN_inits_per_repeat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">generator_seed</span><span class="p">)</span>

            <span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">posterior</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">posteriors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
            <span class="n">repeat_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">posteriors</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">repeat_index</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="run_round" id="run_round"><em>SNPEC</em>.<strong>run_round</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span>
13
<span class="special">14</span>
15
<span class="special">16</span>
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;prior&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">proposal_used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;prior&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_prior</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_gaussian</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_MoG</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;atomic&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_atomic</span><span class="p">(</span><span class="n">combined_loss</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">proposal</span> <span class="o">==</span> <span class="s1">&#39;atomic_comb&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_atomic</span><span class="p">(</span><span class="n">combined_loss</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">()</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="set_proposal" id="set_proposal"><em>SNPEC</em>.<strong>set_proposal</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code></h3>
<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">set_proposal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_to_gaussian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># posterior estimate becomes new proposal prior</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">project_to_gaussian</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">density</span> <span class="o">==</span> <span class="s1">&#39;mog&#39;</span><span class="p">,</span> <span class="s2">&quot;cannot project a MAF&quot;</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">project_to_gaussian</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">posterior</span>
</pre></div>
</td></tr></table>

</details>
<h3 data-toc-label="standardize_init" id="standardize_init"><em>SNPEC</em>.<strong>standardize_init</strong><code class="codehilite"><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span></code></h3>
<div class="codehilite"><pre><span></span>Standardizes the network initialization on obs

Ensures output distributions for xo have mean zero and unit variance.
Alters hidden layers to propagates x=xo as zero to the last layer, and
alters the MoG layers to produce the desired output distribution.
</pre></div>

<details class="info"><summary>Source Code</summary><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
<span class="special"> 2</span>
 3
<span class="special"> 4</span>
 5
<span class="special"> 6</span>
 7
<span class="special"> 8</span>
 9
<span class="special">10</span>
11
<span class="special">12</span></pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">standardize_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcv</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">NeuralNet</span><span class="p">)</span>

    <span class="c1"># ensure x&#39; = x - xo</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">centre_on_obs</span><span class="p">()</span>

    <span class="c1"># ensure x&#39; = 0 stays zero up to MoG layer (setting biases to zero)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">remove_hidden_biases</span><span class="p">()</span>

    <span class="c1"># ensure MoG returns standardized output on x&#39; = 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">conditional_norm</span><span class="p">(</span><span class="n">fcv</span><span class="p">)</span>
</pre></div>
</td></tr></table>

</details>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../generator/" title="Generator" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Generator
              </span>
            </div>
          </a>
        
        
          <a href="../neuralnet/" title="Neural Networks" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Neural Networks
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/mackelab/delfi" class="md-footer-social__link fa fa-github"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.ac79c3b0.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"></script>
      
        <script src="../../static/katex.js"></script>
      
        <script src="../../static/nav.js"></script>
      
    
  </body>
</html>